<!-- Do not edit this file. It is automatically generated by API Documenter. -->

[Home](./index.md) &gt; [promizr](./promizr.md)

## promizr package

Promise extensions and utility methods.

## Classes

|  Class | Description |
|  --- | --- |
|  [PriorityQueue](./promizr.priorityqueue.md) | A PriorityQueue is like a [Queue](./promizr.queue.md) but executes items in priority order. |
|  [PriorityTaskQueue](./promizr.prioritytaskqueue.md) | The same as [PriorityQueue](./promizr.priorityqueue.md) but items are the tasks to execute. |
|  [ProgressPromise](./promizr.progresspromise.md) | A ProgressPromise is a special Promise which allows to track progress of the inner process. |
|  [Queue](./promizr.queue.md) | A Queue runs a <code>worker</code> function on each item that it contains but limit the number of concurrent runs. |
|  [QueueError](./promizr.queueerror.md) | An Error that is thrown when a Queue execution fails and <code>waitToReject</code> option is set to true. |
|  [TaskQueue](./promizr.taskqueue.md) | The same as [Queue](./promizr.queue.md) but items are the tasks to execute. |

## Functions

|  Function | Description |
|  --- | --- |
|  [apply(action, args)](./promizr.apply.md) | Create a new Task which exec <code>task</code> with given arguments. |
|  [applyEach(tasks)](./promizr.applyeach.md) | Prepare a new function which call all <code>tasks</code> in parallel with given arguments. Returns an array with the result of all <code>tasks</code>. |
|  [applyEachSeries(tasks)](./promizr.applyeachseries.md) | The same as [applyEach()](./promizr.applyeach.md)<!-- -->, only <code>tasks</code> are applied in series. The next <code>task</code> is only called once the current one has completed. This means the <code>task</code> functions will complete in order. |
|  [applyOn(owner, task, args)](./promizr.applyon.md) | Same as [apply()](./promizr.apply.md) but call the <code>task</code> with <code>owner</code> <code>this</code> context. If task is a string, it calls <code>owner[task]</code> function. |
|  [applyOn(owner, task, args)](./promizr.applyon_1.md) | Same as [apply()](./promizr.apply.md) but call the <code>task</code> with <code>owner</code> <code>this</code> context |
|  [cbpromisify(fn)](./promizr.cbpromisify.md) | Build a function that transform a multi-callback style function to a Promise version. |
|  [cbpromisify(owner, fn)](./promizr.cbpromisify_1.md) | Build a function that transform a multi-callback style function to a Promise version. |
|  [compose(tasks)](./promizr.compose.md) | Prepare a new function that transfer its arguments to the last <code>task</code> then calls each <code>task</code> using the result of the previous <code>task</code>. Resolves with the result of the first <code>task</code>.<!-- -->Note: Execution order if from end to start. |
|  [concat(array, iterator)](./promizr.concat.md) | Applies <code>iterator</code> to each item in <code>array</code>, concatenating the results. Returns the concatenated list.<!-- -->The <code>iterator</code>s are called in parallel, and the results are concatenated as they return. There is no guarantee that the results array will be returned in the original order of <code>array</code> passed to the <code>iterator</code> function. |
|  [concatSeries(array, iterator)](./promizr.concatseries.md) | Same as [concat()](./promizr.concat.md)<!-- -->, but executes in series instead of parallel. |
|  [defer()](./promizr.defer.md) | Returns a new Deferred object.<!-- -->A Deferred object is an object containing 3 properties: <code>resolve</code>, <code>reject</code> and <code>promise</code>. The <code>resolve</code> function resolves the <code>promise</code>. The <code>reject</code> function rejects the <code>promise</code>. |
|  [denodify(fn, args)](./promizr.denodify.md) | Same as  but call the function immediately. |
|  [denodify(owner, fn, args)](./promizr.denodify_1.md) | Same as  but call the function immediately. |
|  [dir(task, args)](./promizr.dir.md) | Utility function to log using <code>console.dir</code> the result or the error of the given <code>task</code>. If the <code>task</code> succeeds, its result is returned. If the <code>task</code> failed, the error is thrown. |
|  [doUntil(task, test)](./promizr.dountil.md) | The opposite of [doWhilst()](./promizr.dowhilst.md)<!-- -->. Calls the <code>task</code> function until the <code>test</code> function returns <code>true</code>.<!-- -->Note: <code>test</code> is called after the first task. |
|  [doWhilst(task, test)](./promizr.dowhilst.md) | Equivalent of <code>do</code>, <code>while</code> loop. Calls the <code>task</code> function while the <code>test</code> function returns <code>true</code>.<!-- -->Note: <code>test</code> is called after the first task. |
|  [each(array, iterator)](./promizr.each.md) | Applies the function <code>iterator</code> to each item in <code>arr</code>, in parallel. The <code>iterator</code> is called with an item from the list, the index of this item and the list itself. If the <code>iterator</code> emit a rejected Promise, the each function <code>Promise</code> result is instantly rejected.<!-- -->Note: since this function applies <code>iterator</code> to each item in parallel, there is no guarantee that the iterator functions will complete in order. |
|  [eachLimit(array, limit, iterator, options)](./promizr.eachlimit.md) | Sames as [each()](./promizr.each.md) but limit the number of concurrent iterator. |
|  [eachSeries(array, iterator)](./promizr.eachseries.md) | The same as [each()](./promizr.each.md)<!-- -->, only <code>iterator</code> is applied to each item in <code>array</code> in series. The next <code>iterator</code> is only called once the current one has completed. This means the <code>iterator</code> functions will complete in order. |
|  [every(array, iterator)](./promizr.every.md) | Returns <code>true</code> if every element in <code>array</code> satisfies an async test. |
|  [exec(task, args)](./promizr.exec.md) | Execute <code>task</code> with given arguments by ensuring that the result is a Promise. If task throws synchronously, it's wrapped as a Promise. |
|  [execOn(owner, task, args)](./promizr.execon.md) | Sames as [exec()](./promizr.exec.md) but use <code>owner</code> as <code>this</code> context when calling <code>task</code>. |
|  [filter(array, iterator)](./promizr.filter.md) | Returns a new array of all the values in <code>array</code> which pass an async truth test. The Promise returned by each <code>iterator</code> call can only returns <code>boolean</code> value! This operation is performed in parallel, the results array could be in a different order as the original. If the order matters, you could use the <code>findSeries</code> function. |
|  [filterSeries(array, iterator)](./promizr.filterseries.md) | The same as [filter()](./promizr.filter.md) only the <code>iterator</code> is applied to each item in <code>array</code> in series. The next <code>iterator</code> is only called once the current one has completed. The results array will be in the same order as the original. |
|  [find(array, iterator)](./promizr.find.md) | Returns the first value in <code>array</code> that passes an async truth test. The <code>iterator</code> is applied in parallel, meaning the first iterator to return <code>true</code> resolve the global <code>find</code> Promise. That means the result might not be the first item in the original <code>array</code> (in terms of order) that passes the test. If order within the original <code>array</code> is important, then look at <code>findSeries</code>. |
|  [findSeries(array, iterator)](./promizr.findseries.md) | The same as [find()](./promizr.find.md)<!-- -->, only the <code>iterator</code> is applied to each item in <code>array</code> in series. This means the result is always the first in the original <code>array</code> (in terms of array order) that passes the truth test. |
|  [forever(task)](./promizr.forever.md) | Calls the <code>task</code> indefinitely. Note: if <code>task</code> throws, the process stops. |
|  [immediate()](./promizr.immediate.md) | Returns a Promise that resolves on next tick. |
|  [log(task, args)](./promizr.log.md) | Utility function to log the result or the error of the given <code>task</code>. If the <code>task</code> succeeds, its result is returned. If the <code>task</code> failed, the error is thrown. |
|  [map(array, iterator)](./promizr.map.md) | Produces a new array of values by mapping each value in <code>array</code> through the <code>iterator</code> function. The <code>iterator</code> is called with an item from the list, the index of this item and the list itself. If the <code>iterator</code> emit a rejected Promise, the each function <code>Promise</code> result is instantly rejected.<!-- -->Note, that since this function applies the <code>iterator</code> to each item in parallel, there is no guarantee that the <code>iterator</code> functions will complete in order. However, the results array will be in the same order as the original <code>arr</code>. |
|  [mapLimit(array, limit, iterator, options)](./promizr.maplimit.md) | Sames as [map()](./promizr.map.md) but limit the number of iterators that run concurrently.<!-- -->Note: The resulting array may not be in the same order as the source array. |
|  [mapSeries(array, iterator)](./promizr.mapseries.md) | The same as [map()](./promizr.map.md)<!-- -->, only the <code>iterator</code> is applied to each item in <code>array</code> in series. The next <code>iterator</code> is only called once the current one has completed. The results array will be in the same order as the original. |
|  [memoize(task, hash)](./promizr.memoize.md) | Prepare a function that call the <code>task</code> and memoize the result to avoid calling it again. If <code>hash</code> is <code>true</code>, memoize the result based on a hash of input arguments (default hash function: <code>JSON.stringify(args)</code>). If <code>hash</code> is a function, memoize the result based on the hash returned by the function (signature: (args: any\[\]) =<!-- -->&gt; string).<!-- -->Note: The <code>hash</code> function is synchronous. |
|  [nextTick(callback)](./promizr.nexttick.md) | Same as  but could not be aborted. |
|  [parallel(tasks)](./promizr.parallel.md) | Run given tasks in parallel and resolves with an array of the results of each task. |
|  [parallel(obj)](./promizr.parallel_1.md) | Run found tasks in given object in parallel and resolves with an object where all tasks are resolved to their values. |
|  [parallelLimit(tasks, limit, options)](./promizr.parallellimit.md) | Sames as  but limit the number of tasks that run concurrently.<!-- -->Note: The resulting array may not be in the same order as the source array. |
|  [parallelLimit(tasks, limit, options)](./promizr.parallellimit_1.md) | Sames as  but limit the number of tasks that run concurrently. |
|  [partial(task, preArgs)](./promizr.partial.md) | Create a new function which exec <code>task</code> by combining arguments. |
|  [partialOn(owner, task, args)](./promizr.partialon.md) | Same as [partial()](./promizr.partial.md) but call the <code>task</code> with <code>owner</code> <code>this</code> context. If task is a string, it calls <code>owner[task]</code> function. |
|  [partialOn(owner, task, args)](./promizr.partialon_1.md) | Same as [partial()](./promizr.partial.md) but call the <code>task</code> with <code>owner</code> <code>this</code> context |
|  [promisify(fn)](./promizr.promisify.md) | Build a function that transform a Node-Style callback function to a Promise version. |
|  [promisify(owner, fn)](./promizr.promisify_1.md) | Build a function that transform a Node-Style callback function to a Promise version. |
|  [reduce(array, memo, iterator)](./promizr.reduce.md) | Reduces <code>array</code> into a single value using an async <code>iterator</code> to return each successive step. <code>memo</code> is the initial state of the reduction. This function only operates in series.<!-- -->For performance reasons, it may make sense to split a call to this function into a parallel map, and then use the normal <code>Array.prototype.reduce</code> on the results.<!-- -->This function is for situations where each step in the reduction needs to be async; if you can get the data before reducing it, then it's probably a good idea to do so. |
|  [reduceRight(array, memo, iterator)](./promizr.reduceright.md) | Same as [reduce()](./promizr.reduce.md)<!-- -->, only operates on <code>array</code> in reverse order. |
|  [reject(array, iterator)](./promizr.reject.md) | The opposite of [filter()](./promizr.filter.md)<!-- -->. Removes values that pass an <code>async</code> truth test. |
|  [rejectSeries(array, iterator)](./promizr.rejectseries.md) | The same as [reject()](./promizr.reject.md)<!-- -->, only the <code>iterator</code> is applied to each item in <code>array</code> in series. |
|  [retry(times, task)](./promizr.retry.md) | Executes the <code>task</code> and retry if failed. If <code>task</code> fails the given number of <code>times</code>, the promise is rejected. |
|  [seq(tasks)](./promizr.seq.md) | Prepare a new function that transfer its arguments to the fist <code>task</code> then calls each <code>task</code> using the result of the previous <code>task</code>. Resolves with the result of the last <code>task</code>. Note: Execution order if from start to end. |
|  [series(tasks)](./promizr.series.md) | Run given tasks in parallel and resolves with an array of the results of each task. |
|  [series(tasks)](./promizr.series_1.md) | Run found tasks in given object in series and resolves with an object where all tasks are resolved to their values. |
|  [some(array, iterator)](./promizr.some.md) | Returns <code>true</code> if at least one element in the <code>array</code> satisfies an async test. The <code>Promise</code> returned by each <code>iterator</code> call can only returns boolean value! Once any iterator call returns <code>true</code>, the main <code>Promise</code> is resolved. |
|  [sortBy(array, iterator)](./promizr.sortby.md) | Sorts a list by the results of running each <code>array</code> value through an async <code>iterator</code>. |
|  [tap(task, args)](./promizr.tap.md) | Build a function that takes an argument, calls the <code>task</code> and resolve with the input argument. This function is usefull to call a function during a Promise chain without breaking the chain. |
|  [tapOn(owner, task, args)](./promizr.tapon.md) | The sames as [tap()](./promizr.tap.md) but apply the <code>task</code> with <code>owner</code> as this context. |
|  [tapOn(owner, task, args)](./promizr.tapon_1.md) | The sames as [tap()](./promizr.tap.md) but apply the <code>task</code> with <code>owner</code> as this context. |
|  [timeout(ms)](./promizr.timeout.md) | Returns a Promise that resolves when timer is done. |
|  [times(times, task)](./promizr.times.md) | Executes <code>task</code> the given number of <code>times</code>. Returns an array with the result of each <code>task</code> execution. |
|  [timesSeries(times, task)](./promizr.timesseries.md) | The same as [times()](./promizr.times.md)<!-- -->, only <code>tasks</code> are applied in series. The next <code>task</code> is only called once the current one has completed. |
|  [uncallbackify(fn, args)](./promizr.uncallbackify.md) | Same as  but call the function immediately. |
|  [uncallbackify(owner, fn, args)](./promizr.uncallbackify_1.md) | Same as  but call the function immediately. |
|  [until(test, task)](./promizr.until.md) | The opposite of [whilst()](./promizr.whilst.md)<!-- -->. Calls the <code>task</code> function until the <code>test</code> function returns <code>true</code>. |
|  [waterfall(tasks)](./promizr.waterfall.md) | Calls each <code>task</code> using the result of the previous <code>task</code>. Resolves with the result of the last <code>task</code>. The first <code>task</code> should not take any argument. |
|  [whilst(test, task)](./promizr.whilst.md) | Equivalent of <code>while</code> loop. Calls the <code>task</code> function while the <code>test</code> function returns <code>true</code>. |

## Interfaces

|  Interface | Description |
|  --- | --- |
|  [PriorityQueueOptions](./promizr.priorityqueueoptions.md) | Options to create a PriorityQueue. |
|  [QueueOptions](./promizr.queueoptions.md) | Options to create a Queue. |

## Variables

|  Variable | Description |
|  --- | --- |
|  [clearImmediate\_2](./promizr.clearimmediate_2.md) | Abort a previously  callback. |
|  [resolve](./promizr.resolve.md) | Alias for <code>Promise.resolve</code>. |
|  [setImmediate\_2](./promizr.setimmediate_2.md) | Use the best setImmediate equivalent function depending on platform. |

## Type Aliases

|  Type Alias | Description |
|  --- | --- |
|  [Async](./promizr.async.md) | Utility type to wrap value in a Promise. |
|  [AsyncFunction](./promizr.asyncfunction.md) | A function that may return a Promise. |
|  [AsyncListIterator](./promizr.asynclistiterator.md) | Asynchronous list iterator function. |
|  [AsyncReduceIterator](./promizr.asyncreduceiterator.md) | Asynchronous reduce iterator function. |
|  [AsyncTask](./promizr.asynctask.md) | A function that take no arguments and may return a Promise. |
|  [Awaited](./promizr.awaited.md) | Utility type to extract Promise resolution Type. |
|  [AwaitedObject](./promizr.awaitedobject.md) | Transform a source object in an object where every AsyncTask is awaited. |
|  [Deferred](./promizr.deferred.md) | A Deferred is an object to control a Promise outside of executor. |

